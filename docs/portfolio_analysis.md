# Concurrent Order Book — 포트폴리오 기술 분석

---

## 1. 프로젝트 5줄 요약

C++17로 구현한 금융 거래소용 **한계 주문 장부(Limit Order Book)**이다.
"읽기가 많은 환경에서 `shared_mutex`가 `mutex`보다 빠를 것이다"라는 가설을 직접 측정으로 검증했다.
컴파일 타임 템플릿으로 락 정책을 교체 가능하게 설계해, 동일한 로직 위에서 두 정책을 공정하게 비교했다.
결과는 예상과 반대: `mutex`가 모든 구성(스레드 수 × 워크로드)에서 처리량 최대 3.6배, p99 레이턴시 3.3배 우위를 보였다.
측정값과 그 원인(임계 구역 길이, 리더 카운트 경합, macOS 구현 특성)을 분석해 문서로 정리했다.

---

## 2. 핵심 기술 스택

| 분류 | 내용 |
|------|------|
| **언어** | C++17 |
| **동시성** | `std::mutex`, `std::shared_mutex`, POSIX pthreads |
| **빌드** | CMake 3.10+, Apple Clang, `-O3` |
| **자료구조** | `std::map` (가격 레벨 정렬), `std::unordered_map` (O(1) 취소 조회), `std::list` (가격 레벨 내 FIFO) |
| **설계 패턴** | Policy-based design (컴파일 타임 템플릿 파라미터) |
| **벤치마킹** | 자체 작성 멀티스레드 벤치마크 + CSV 결과 |
| **시각화** | Python / matplotlib |
| **플랫폼** | macOS, Apple Silicon (ARM64) |

---

## 3. 담당 역할 / 구현 기능

**전체 설계·구현·분석을 단독으로 진행한 개인 프로젝트.**

### 핵심 구현

- **주문 장부 엔진**: Limit / Market / Cancel 세 가지 주문 타입, 가격-시간 우선순위(Price-Time Priority) 매칭
- **컴파일 타임 락 정책 추상화**
  ```cpp
  // 동일한 OrderBook 템플릿에 정책만 교체
  OrderBook<MutexPolicy>       // exclusive lock
  OrderBook<SharedMutexPolicy> // read-shared / write-exclusive
  ```
  두 정책 모두 동일한 테스트 스위트를 통과하도록 설계해 공정한 비교를 보장.
- **O(1) 취소 조회**: `unordered_map<id, Order*>`로 취소 시 가격 레벨 선형 탐색 없이 직접 접근
- **멀티스레드 벤치마크**: 3가지 워크로드(read_heavy 95/5, balanced 70/20/10, write_heavy 20/30/50) × 4가지 스레드 수(1/2/4/8), 처리량(ops/sec) + p99 레이턴시 측정
- **정확성 테스트 10종**: 단일 스레드 단위 테스트 + 4스레드 40k ops 동시성 충돌/데드락 검증

### 발견 및 수정한 버그: 허상 포인터(Dangling Pointer)

`cancel_order` 내부에서 `std::list::remove_if`가 노드를 해제한 뒤 같은 포인터로 `price`를 읽는 UB 발생.
초기 테스트 4종은 모두 취소 후 `total_orders()`만 확인해 관측되지 않았고, 멀티 레벨 북에서 `best_bid_price()`를 검증하는 테스트를 추가하고서야 발견.
**수정**: `remove_if` 호출 전 `price`를 지역 변수로 복사해 포인터 생존 시간 의존성 제거.

---

## 4. 기술적으로 어려웠던 부분과 해결 방법

### (1) 가설이 틀렸을 때: 측정값 해석

`shared_mutex`가 읽기 중심 워크로드에서 유리하리라 예상했지만 결과는 정반대였다.
"측정이 틀렸나?"가 아니라 "왜 이런 결과가 나왔는가"를 파고들었다.

**원인 분석 (3가지)**:
1. **임계 구역이 너무 짧다** — `best_bid_price()`는 `rbegin()` 역참조 한 번(≈10~20 ns). `shared_mutex`의 리더 카운트 원자 연산 오버헤드가 실제 작업량보다 크다.
2. **리더 카운트 자체가 경합 지점** — 8개 스레드가 같은 원자 변수를 빠르게 increment/decrement하면 캐시 라인이 코어 간을 오가는 False Sharing이 발생한다. `mutex`는 이 카운터 자체가 없다.
3. **macOS 구현 특성** — `std::mutex`는 `os_unfair_lock`(공정성 없음, 빠름), `std::shared_mutex`는 `pthread_rwlock`(작가 기아 방지 공정성 로직 포함, 오버헤드 있음).

**결론**: "어떤 락이 더 좋다"가 아니라 "임계 구역 길이와 플랫폼에 따라 측정해야 한다"는 원칙을 직접 확인했다.

### (2) 허상 포인터 버그 (Dangling Pointer)

`remove_if`가 리스트 노드를 파괴한 뒤 같은 포인터로 멤버를 읽는 코드가 존재했다.
UB이므로 대부분의 실행에서 우연히 동작하다가, 특정 메모리 레이아웃에서만 잘못된 가격 레벨을 지웠다.
**발견 방법**: 엣지 케이스("베스트 가격 주문을 취소하면 다음 레벨이 노출되는가")를 커버하는 테스트를 추가하다가 실패.
**수정**: 포인터 역참조보다 먼저 값을 복사 (`uint64_t price = order_ptr->price;`).

### (3) 벤치마크 설계의 공정성 확보

- 같은 시드(42)로 난수를 고정해 재현 가능한 워크로드 생성
- 락 정책 외 모든 조건(자료구조, 알고리즘, 주문 시퀀스)을 동일하게 유지
- 컴파일 타임 정책으로 런타임 분기 없이 순수한 락 차이만 측정

---

## 5. 이 프로젝트에서 드러나는 관심사와 강점

| 강점 | 구체적 근거 |
|------|-------------|
| **"측정하기 전에 결론 내리지 않는다"** | shared_mutex 가설이 틀렸을 때 결과를 버리지 않고 원인을 분석해 문서화 |
| **저수준 시스템 이해** | 원자 연산, 캐시 라인 경합, OS 락 구현 차이까지 추적 |
| **설계 추상화** | Policy-based design으로 로직 중복 없이 두 구현을 교체 가능하게 분리 |
| **버그 재현과 근본 원인 분석** | UB를 "우연히 동작함"으로 넘기지 않고 테스트로 재현, 원인과 수정 과정을 문서로 남김 |
| **관심 도메인: 고성능 금융 시스템** | 거래소 핵심 컴포넌트를 직접 구현하고 성능 특성을 실증적으로 탐구 |

---

## 6. 프로젝트 규모

| 항목 | 내용 |
|------|------|
| **팀 구성** | 1인 (개인 프로젝트) |
| **개발 언어 및 코드량** | C++17, 소스 ~300 LOC + 테스트/벤치마크 |
| **벤치마크 규모** | 스레드당 100,000 ops, 최대 8스레드, 총 12개 구성 × 2 정책 = 24 케이스 |
| **처리량 피크** | 단일 스레드 balanced 워크로드: 15.7M ops/sec |
| **외부 의존성** | 표준 라이브러리 + CMake + Python(시각화)만 사용 |
| **사용자** | 없음 (연구/학습 목적 프로젝트) |
